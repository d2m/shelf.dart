// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library shelf.middleware;

import 'request.dart';
import 'response.dart';
import 'typedef.dart';
import 'util.dart';

/// A function which creates a new [ShelfHandler] by wrapping a [ShelfHandler].
///
/// You can extend the functions of a [ShelfHandler] by wrapping it in
/// [ShelfMiddleware] that can intercept and process a request before it it sent
/// to a handler, a response after it is sent by a handler, or both.
///
/// Because [ShelfMiddleware] consumes a [ShelfHandler] and returns a new
/// [ShelfHandler], multiple [ShelfMiddleware] instances can be composed
/// together to offer rich functionality.
///
/// Common uses for middleware include caching, logging, and authentication.
///
/// A simple [ShelfMiddleware] can be created using [createMiddleware].
typedef ShelfHandler ShelfMiddleware(ShelfHandler innerHandler);

/// Creates a [ShelfMiddleware] using the provided functions.
///
/// If provided, [requestHandler] receives a [ShelfRequest]. It can respond to
/// the request by returning a [ShelfResponse] or [Future<ShelfResponse>].
/// [requestHandler] can also return `null` for some or all requests in which
/// case the request is sent to the inner [ShelfHandler].
///
/// If provided, [responseHandler] is called with the [ShelfResponse] generated
/// by the inner [ShelfHandler]. Responses generated by [requestHandler] are not
/// sent to [responseHandler].
///
/// [responseHandler] should return either a [ShelfResponse] or
/// [Future<ShelfResponse>]. It may return the response parameter it receives or
/// create a new response object.
///
/// If provided, [errorHandler] receives errors thrown by the inner handler. It
/// does not receive errors thrown by [requestHandler] or [responseHandler]. It
/// can either return a new response or throw an error.
ShelfMiddleware createMiddleware({requestHandler(ShelfRequest request),
    responseHandler(ShelfResponse response),
    errorHandler(error, StackTrace stackTrace)}) {
  if (requestHandler == null) requestHandler = (request) => null;

  if (responseHandler == null) {
    responseHandler = (ShelfResponse response) {
      return response;
    };
  }

  return (ShelfHandler innerHandler) {
    return (request) {
      return syncFuture(() => requestHandler(request)).then((response) {
        if (response != null) return response;

        return syncFuture(() => innerHandler(request))
            .then((response) => responseHandler(response),
                onError: errorHandler);
      });
    };
  };
}
